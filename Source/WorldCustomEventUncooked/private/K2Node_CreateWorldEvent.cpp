// Fill out your copyright notice in the Description page of Project Settings.


#include "K2Node_CreateWorldEvent.h"
#include "WorldCustomEventUncooked.h"

#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintFunctionNodeSpawner.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraph/EdGraphNode.h"
#include "Engine/MemberReference.h"
#include "UObject/UnrealType.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "Kismet2/CompilerResultsLog.h"

#include "K2Node_MacroInstance.h"
#include "K2Node_CallFunction.h"
#include "K2Node_IfThenElse.h"
#include "K2Node_CustomEvent.h"
#include "K2Node_AddDelegate.h"
#include "K2Node_CreateDelegate.h"
#include "K2Node_Self.h"

#include "KismetCompiler.h"
#include "Kismet/KismetSystemLibrary.h"

#include "WorldEventSubsystem.h"

#define LOCTEXT_NAMESPACE "World Custom Event"

UK2Node_CreateWorldEvent::UK2Node_CreateWorldEvent(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
{
	ProxyActivateEventFunctionName = GET_FUNCTION_NAME_CHECKED(UWorldEventObject, ActivateEvent);
}


void UK2Node_CreateWorldEvent::AllocateDefaultPins()
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	//기본 실행 핀들
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	UFunction* FactoryFunction = GetFactoryFunction();

	//World Event Delegate 뽑아내기
	UFunction* DelegateSignatureFunction = nullptr;
	for (TFieldIterator<FProperty> PropertyIt(ProxyClass); PropertyIt; ++PropertyIt)
	{
		if (FMulticastDelegateProperty* Property = CastField<FMulticastDelegateProperty>(*PropertyIt))
		{
			UEdGraphPin* ExecPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, Property->GetFName());
			ExecPin->PinToolTip = Property->GetToolTipText().ToString();
			ExecPin->PinFriendlyName = Property->GetDisplayNameText();

			if (!DelegateSignatureFunction)
			{
				DelegateSignatureFunction = Property->SignatureFunction;
			}
		}
	}

	bool bAllPinsGood = true;
	if (FactoryFunction)
	{
		//World Context는 UPROPERTY로 자동으로 들어가니 숨기기
		TSet<FName> PinsToHide;
		FBlueprintEditorUtils::GetHiddenPinsForFunction(GetGraph(), FactoryFunction, PinsToHide);

		for (TFieldIterator<FProperty> PropIt(FactoryFunction); PropIt && (PropIt->PropertyFlags & CPF_Parm); ++PropIt)
		{
			FProperty* Param = *PropIt;

			//매개 변수인지 체크
			const bool bIsFunctionInput = !Param->HasAnyPropertyFlags(CPF_OutParm) || Param->HasAnyPropertyFlags(CPF_ReferenceParm);
			if (!bIsFunctionInput) { continue; }

			UEdGraphNode::FCreatePinParams PinParams;
			PinParams.bIsReference = Param->HasAnyPropertyFlags(CPF_ReferenceParm);
			UEdGraphPin* Pin = CreatePin(EGPD_Input, NAME_None, Param->GetFName(), PinParams);
			const bool bPinGood = (Pin && K2Schema->ConvertPropertyToPinType(Param, /*out*/ Pin->PinType));

			if (bPinGood)
			{
				const FString& PinDisplayName = Param->GetMetaData(FBlueprintMetadata::MD_DisplayName);
				if (!PinDisplayName.IsEmpty()) { Pin->PinFriendlyName = FText::FromString(PinDisplayName); }

				//AdvancePin인가
				const bool bAdvancedPin = Param->HasAllPropertyFlags(CPF_AdvancedDisplay);
				Pin->bAdvancedView = bAdvancedPin;
				if (bAdvancedPin && (ENodeAdvancedPins::NoPins == AdvancedPinDisplay))
				{
					AdvancedPinDisplay = ENodeAdvancedPins::Hidden;
				}
			
				//매개 변수 기본값 넣는다면? 넣어주기
				Pin->bDefaultValueIsIgnored = Param->HasAllPropertyFlags(CPF_ConstParm | CPF_ReferenceParm) &&
											 (!FactoryFunction->HasMetaData(FBlueprintMetadata::MD_AutoCreateRefTerm) || Pin->PinType.IsContainer());

				FString ParamValue;
				if (K2Schema->FindFunctionParameterDefaultValue(FactoryFunction, Param, ParamValue))
				{
					K2Schema->SetPinAutogeneratedDefaultValue(Pin, ParamValue);
				}
				else
				{
					K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
				}

				//Pin 숨김 : World Context 핀 숨김
				if (PinsToHide.Contains(Pin->PinName))
				{
					Pin->bHidden = true;
				}
			}

			bAllPinsGood &= bPinGood;
		}
	}

	if (!bAllPinsGood)
	{
		LOG_ERROR(TEXT("%s 핀이 제대로 생성되지 못함"), *FactoryFunction->GetName() );
	}
}

FText UK2Node_CreateWorldEvent::GetTooltipText() const
{
	return LOCTEXT("Create World Custom Event Node ToolTipText", "Create New World Custom Event And Register in World Event Manger.");
}

FText UK2Node_CreateWorldEvent::GetToolTipHeading() const
{
	return LOCTEXT("Create World Custom Event Node ToolTipHeading", "Create New World Custom Event");
}

FText UK2Node_CreateWorldEvent::GetNodeTitle(ENodeTitleType::Type TitleType) const
{	
	return LOCTEXT("Create World Custom Event Node Title", "Create World Event");
}

bool UK2Node_CreateWorldEvent::IsCompatibleWithGraph(const UEdGraph* TargetGraph) const
{
	EGraphType GraphType = TargetGraph->GetSchema()->GetGraphType(TargetGraph);
	bool bIsCompatible = GraphType == EGraphType::GT_Ubergraph || GraphType == EGraphType::GT_Function || GraphType == EGraphType::GT_Macro;

	return bIsCompatible && Super::IsCompatibleWithGraph(TargetGraph);
}

void UK2Node_CreateWorldEvent::ValidateNodeDuringCompilation(FCompilerResultsLog& MessageLog) const
{
	Super::ValidateNodeDuringCompilation(MessageLog);

	if (UObject const* SourceObject = MessageLog.FindSourceObject(this))
	{
		// Lets check if it's a result of macro expansion, to give a helpful error
		if (UK2Node_MacroInstance const* MacroInstance = Cast<UK2Node_MacroInstance>(SourceObject))
		{
			// Since it's not possible to check the graph's type, just check if this is a ubergraph using the schema's name for it
			if (!(GetGraph()->HasAnyFlags(RF_Transient) && GetGraph()->GetName().StartsWith(UEdGraphSchema_K2::FN_ExecuteUbergraphBase.ToString())))
			{
				MessageLog.Error(*LOCTEXT("Node In Function From Macro", "@@ is being used in Function '@@' resulting from expansion of Macro '@@'").ToString(), this, GetGraph(), MacroInstance);
			}
		}
	}
}

FString UK2Node_CreateWorldEvent::GetPinMetaData(FName InPinName, FName InKey)
{
	FString MetaData = Super::GetPinMetaData(InPinName, InKey);

	if (MetaData.IsEmpty())
	{
		if (UFunction* Function = GetFactoryFunction())
		{
			if (FProperty* Property = Function->FindPropertyByName(InPinName))
			{
				MetaData = Property->GetMetaData(InKey);
			}

			if (MetaData.IsEmpty())
			{
				MetaData = Function->GetMetaData(InKey);
				if (MetaData != InPinName.ToString())
				{
					MetaData.Empty();
				}
			}
		}
	}

	return MetaData;
}

bool UK2Node_CreateWorldEvent::HasExternalDependencies(TArray<class UStruct*>* OptionalOutput) const
{
	const UBlueprint* SourceBlueprint = GetBlueprint();

	const bool bProxyFactoryResult = (ProxyFactoryClass != nullptr) && (ProxyFactoryClass->ClassGeneratedBy != SourceBlueprint);
	if (bProxyFactoryResult && OptionalOutput)
	{
		OptionalOutput->AddUnique(ProxyFactoryClass);
	}

	const bool bProxyResult = (ProxyClass != nullptr) && (ProxyClass->ClassGeneratedBy != SourceBlueprint);
	if (bProxyResult && OptionalOutput)
	{
		OptionalOutput->AddUnique(ProxyClass);
	}

	const bool bSuperResult = Super::HasExternalDependencies(OptionalOutput);
	return bProxyFactoryResult || bProxyResult || bSuperResult;
}



void UK2Node_CreateWorldEvent::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{

	Super::ExpandNode(CompilerContext, SourceGraph);

	const UEdGraphSchema_K2* Schema = CompilerContext.GetSchema();
	check(SourceGraph && Schema);

	//최종 확인
	bool bIsErrorFree = true;

	//Create World Event 함수와 묶기
	UK2Node_CallFunction* const CreateWorldEventNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
	CreateWorldEventNode->FunctionReference.SetExternalMember(ProxyFactoryFunctionName, ProxyFactoryClass);
	CreateWorldEventNode->AllocateDefaultPins();
	if (CreateWorldEventNode->GetTargetFunction() == nullptr)
	{
		const FText ClassName = ProxyFactoryClass ? FText::FromString(ProxyFactoryClass->GetName()) : LOCTEXT("MissingClassString", "Unknown Class");
		const FString FormattedMessage = FText::Format(
			LOCTEXT("Make Event Error Format", "World Custom Event: Missing function {0} from class {1} @@"),
			FText::FromString(ProxyFactoryFunctionName.GetPlainNameString()),
			ClassName
		).ToString();

		CompilerContext.MessageLog.Error(*FormattedMessage, this);
		return;
	}

	bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*FindPinChecked(UEdGraphSchema_K2::PN_Execute), *CreateWorldEventNode->FindPinChecked(UEdGraphSchema_K2::PN_Execute)).CanSafeConnect();

	UEdGraphPin* CreateEventThenPin = CreateWorldEventNode->GetThenPin();

	//매개변수들 묶기
	for (UEdGraphPin* CurrentPin : Pins)
	{
		if (FCreateWorldEventHelper::ValidDataPin(CurrentPin, EGPD_Input))
		{
			UEdGraphPin* DestPin = CreateWorldEventNode->FindPin(CurrentPin->PinName); // match function inputs, to pass data to function from CallFunction node
			bIsErrorFree &= DestPin && CompilerContext.MovePinLinksToIntermediate(*CurrentPin, *DestPin).CanSafeConnect();
		}
	}

	UEdGraphPin* CreatedEventObjPin = CreateWorldEventNode->GetReturnValuePin();
	check(CreatedEventObjPin);

	//Event Delegate 연결하기
	UEdGraphPin* LastThenPin = CreateEventThenPin;

	for (TFieldIterator<FMulticastDelegateProperty> PropertyIt(ProxyClass); PropertyIt && bIsErrorFree; ++PropertyIt)
	{
		UEdGraphPin* PinForCurrentDelegateProperty = FindPin(PropertyIt->GetFName());
		if (!PinForCurrentDelegateProperty || (UEdGraphSchema_K2::PC_Exec != PinForCurrentDelegateProperty->PinType.PinCategory))
		{
			FText ErrorMessage = FText::Format(LOCTEXT("Wrong Delegate Property", "Create World Event: Cannot find execution pin for delegate "), FText::FromString(PropertyIt->GetName()));
			CompilerContext.MessageLog.Error(*ErrorMessage.ToString(), this);
			bIsErrorFree = false;
			break;
		}

		const FName FuncNameForBind = *FString::Printf(TEXT("%s_%s"), *PropertyIt->GetName(), *CompilerContext.GetGuid(this));

		//Delegate 추가를 위한 노드		
		UK2Node_AddDelegate* AddDelegateNode = CompilerContext.SpawnIntermediateNode<UK2Node_AddDelegate>(this, SourceGraph);
		AddDelegateNode->SetFromProperty(*PropertyIt, false, ProxyClass);
		AddDelegateNode->AllocateDefaultPins();

		bIsErrorFree &= Schema->TryCreateConnection(CreatedEventObjPin, AddDelegateNode->FindPinChecked(UEdGraphSchema_K2::PN_Self));
		bIsErrorFree &= Schema->TryCreateConnection(LastThenPin, AddDelegateNode->GetExecPin());
		LastThenPin = AddDelegateNode->GetThenPin();

		UK2Node_Self* SelfNode = CompilerContext.SpawnIntermediateNode<UK2Node_Self>(this, SourceGraph);
		SelfNode->AllocateDefaultPins();

		//추가할 Delegate만들기
		UK2Node_CreateDelegate* CreateDelegateNode = CompilerContext.SpawnIntermediateNode<UK2Node_CreateDelegate>(this, SourceGraph);
		CreateDelegateNode->AllocateDefaultPins();
		bIsErrorFree &= Schema->TryCreateConnection(AddDelegateNode->GetDelegatePin(), CreateDelegateNode->GetDelegateOutPin());
		bIsErrorFree &= Schema->TryCreateConnection(SelfNode->FindPinChecked(UEdGraphSchema_K2::PN_Self), CreateDelegateNode->GetObjectInPin());
		CreateDelegateNode->SetFunction(FuncNameForBind);

		//실제 만들 이벤트 노드
		UK2Node_CustomEvent* ActivateEventNode = CompilerContext.SpawnIntermediateNode<UK2Node_CustomEvent>(this, SourceGraph);
		ActivateEventNode->CustomFunctionName = FuncNameForBind;
		ActivateEventNode->AllocateDefaultPins();

		bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*PinForCurrentDelegateProperty, *ActivateEventNode->GetThenPin()).CanSafeConnect();
	}
	

	/* 만약 Event Object 유효한지 필요하면 추가할 것
	// 생성된 Event Is Valid?
	UK2Node_CallFunction* IsValidFuncNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
	const FName IsValidFuncName = GET_FUNCTION_NAME_CHECKED(UKismetSystemLibrary, IsValid);
	IsValidFuncNode->FunctionReference.SetExternalMember(IsValidFuncName, UKismetSystemLibrary::StaticClass());
	IsValidFuncNode->AllocateDefaultPins();
	UEdGraphPin* IsValidInputPin = IsValidFuncNode->FindPinChecked(TEXT("Object"));
	bIsErrorFree &= Schema->TryCreateConnection(CreatedEventObjPin, IsValidInputPin);

	UK2Node_IfThenElse* ValidateEventNode = CompilerContext.SpawnIntermediateNode<UK2Node_IfThenElse>(this, SourceGraph);
	ValidateEventNode->AllocateDefaultPins();
	bIsErrorFree &= Schema->TryCreateConnection(IsValidFuncNode->GetReturnValuePin(), ValidateEventNode->GetConditionPin());

	UEdGraphPin* CreateEventThenPin = CreateWorldEventNode->GetThenPin();
	bIsErrorFree &= Schema->TryCreateConnection(CreateEventThenPin, ValidateEventNode->GetExecPin());
	*/



	bIsErrorFree &= CompilerContext.MovePinLinksToIntermediate(*GetThenPin(), *LastThenPin).CanSafeConnect();

	BreakAllNodeLinks();
}

void UK2Node_CreateWorldEvent::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	struct GetMenuActions_Utils
	{
		static void SetNodeFunc(UEdGraphNode* NewNode, bool /*bIsTemplateNode*/, TWeakObjectPtr<UFunction> FunctionPtr)
		{
			UK2Node_CreateWorldEvent* MakeWorldEventNode = CastChecked<UK2Node_CreateWorldEvent>(NewNode);
			if (FunctionPtr.IsValid())
			{
				UFunction* Func = FunctionPtr.Get();
				FObjectProperty* ReturnProp = CastFieldChecked<FObjectProperty>(Func->GetReturnProperty());

				MakeWorldEventNode->ProxyFactoryFunctionName = Func->GetFName();
				MakeWorldEventNode->ProxyFactoryClass = Func->GetOuterUClass();
				MakeWorldEventNode->ProxyClass = ReturnProp->PropertyClass;
			}
		}
	};

	//World Event object 생성을 위한 Factory Action 등록
	UClass* NodeClass = GetClass();
	ActionRegistrar.RegisterClassFactoryActions<UWorldEventObject>(FBlueprintActionDatabaseRegistrar::FMakeFuncSpawnerDelegate::CreateLambda([NodeClass](const UFunction* FactoryFunc) -> UBlueprintNodeSpawner*
		{
			UBlueprintNodeSpawner* NodeSpawner = UBlueprintFunctionNodeSpawner::Create(FactoryFunc);
			check(NodeSpawner != nullptr);
			NodeSpawner->NodeClass = NodeClass;

			TWeakObjectPtr<UFunction> FunctionPtr = MakeWeakObjectPtr(const_cast<UFunction*>(FactoryFunc));
			NodeSpawner->CustomizeNodeDelegate = UBlueprintNodeSpawner::FCustomizeNodeDelegate::CreateStatic(
				GetMenuActions_Utils::SetNodeFunc
				,FunctionPtr
			);

			return NodeSpawner;
		}
	));
}


UFunction* UK2Node_CreateWorldEvent::GetFactoryFunction() const
{
	if (ProxyFactoryClass == nullptr)
	{
		LOG_ERROR(TEXT("Make World Event Target Class is null in %s"), *GetFullName());
		return nullptr;
	}

	FMemberReference FunctionReference;
	FunctionReference.SetExternalMember(ProxyFactoryFunctionName, ProxyFactoryClass);

	UFunction* Factoryfunction = FunctionReference.ResolveMember<UFunction>(GetBlueprint());

	if (Factoryfunction == nullptr)
	{
		Factoryfunction = ProxyFactoryClass->FindFunctionByName(ProxyFactoryFunctionName);
	}

	return Factoryfunction;
}



///////////////////////////////////////////////// Create World Event Helper //////////////////////////////////////

bool UK2Node_CreateWorldEvent::FCreateWorldEventHelper::ValidDataPin(const UEdGraphPin* Pin, EEdGraphPinDirection Direction)
{
	const bool bValidDataPin = Pin
		&& !Pin->bOrphanedPin
		&& (Pin->PinType.PinCategory != UEdGraphSchema_K2::PC_Exec);

	const bool bProperDirection = Pin && (Pin->Direction == Direction);

	return bValidDataPin && bProperDirection;

	
	return false;
}


#undef LOCTEXT_NAMESPACE

